javascript将数据和代码都简化到了最原始的程度

基本数据类型：undefined、null、bololean、number、string

复杂数据类型：object

代码只体现为一种形式：function

所有的简单类型都不是对象，javascript没有将对象化的能力赋予简单类型。只有object类型和funtion类型提供对象化的能力

WebAssembly的概念：

运行在现代网络浏览器中的新型代码，并且提供新的性能和效果，为诸如C、C++和RUST等低级语言提供一个高效的编译目标

为客户端app提供一种在网络平台以接近本地速度的方式运行多语言编写代码的方式

是一门不同于js的语言，被设计为和js一起协同工作的，一门低级的汇编语言，一种紧凑的二进制格式

function？？？？？？

js解析器：js引擎是一种进程虚拟机，js是单线程，为了利用多核计算机的性能，H5提出WebWorker标准，允许js创建多个线程,但子线程

完全受主线程控制，且不得操作DOM

javascript函数只是一个命了名的变量，同一段程序中js引擎会将定义式的函数提前执行******（包括对var变量的创建，初始值为undefined）

对于过程式编程，代码执行的时间和数据标识的空间也是不可分割的，只需将指令执行的具体时刻和标识映射的具体地址结合，才能决定瞬时

状态下的上下文状态，即作用域

有无var的区别：window作用域里的一个变量，window对象的一个属性

函数的caller属性:动态变化，没有被调用或被全局代码调用，为null

this对象，arguments对象

使用eval函数动态执行的代码并不创建新的作用域

最好不要使用arguments的caller属性？？？？

function类型本身具有对象化的能力，并且能和object结合

js中只有function和object才有对象化的能力，函数可以添加和删除属性

对象和函数都能入数组一样，通过属性名或方法名作为下标来访问

object个function的内部实现就是一个字典结构

对象的自我意识：

this只是在任意对象和function元素结合时的一个概念

构建对象的方式

json创建对象

new操作符创建对象：创建一个空对象，然后将空对象和构造函数进行关联（this）

不但具有各自的成员数据，还有各自的方法数据，对象中各自保存了一份代码体

由于这个问题的出现，可以在全局作用域定义一个共享的方法体

不够优雅，随后产生prototype的概念******

js的所有function对象都有一个prototype属性，这个属性本身又是一个object类型的对象，通过一个函数构造的对象

都可以访问到函数prototype里的的属性

????原型继承????

原型链的概念，在new时将构造函数的prototype对象指派为对象的内置对象(__prop__)

许多成功的ajax项目的js运行库都大量扩展了内置函数的prototype功能

闭包：在构造函数体内定义另外的函数作为目标对象的方法函数，这个方法函数可以引用外层函数体中的

临时变量（对垃圾回收造成影响）

甘露模型？？？？？

富互联应用：传统网络程序的开发是基于页面的、服务器端数据传递的模式。RIA是下一代的将桌面应用程序的交互的用户体验和传统的web应用的部署灵活性

结合起来的web应用？？？？？

量子纠缠态的大规模式并行编程

js总是被动执行的，一个浏览器中的代码都是串行执行的

除了window和document对象，其他dom对象都是可以动态创建的

DOM对象不是一个纯粹的js对象，浏览器将DOM树实现为原生对象，大都以本机二进制的接口模型出现，浏览器会为

每一个js形式的dom对象创建一个对应的内置原型

封装：让代码规范好用，转换编程的思维角度











